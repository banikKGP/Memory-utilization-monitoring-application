<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=320" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>Performance Monitoring</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
    <script type="text/javascript" src="http://d3js.org/d3.v2.min.js"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <style>
        body {
            /* font-family: Helvetica, Arial, sans-serif; */
            margin: 32px;
        }

        #power-gauge g.arc {
            fill: steelblue;
        }

        #power-gauge g.pointer {
            fill: #e85116;
            stroke: #b64011;
        }

        #power-gauge g.label text {
            text-anchor: middle;
            font-size: 14px;
            font-weight: bold;
            fill: #666;
        }

        body {
            font: 10px sans-serif;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .x.axis path {
            display: none;
        }

        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 1.5px;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-4">
                <div id="power-gauge-cpuutil">
                    <p>CPU Utilization</p>
                </div>
                <div id="power-gauge-ramutil">
                    <p>RAM Utilization</p>
                </div>
            </div>
            <div class="col-md-8">
                <div id="cpu-line-chart">
                    <svg id="cpu"></svg>
                </div>
                <p>CPU Line Chart</p>
            </div>
        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"></script>

    <script>
        var gauge = function (container, configuration) {
            var that = {};
            var config = {
                size: 200,
                clipWidth: 200,
                clipHeight: 110,
                ringInset: 20,
                ringWidth: 20,

                pointerWidth: 10,
                pointerTailLength: 5,
                pointerHeadLengthPercent: 0.9,

                minValue: 0,
                maxValue: 10,

                minAngle: -90,
                maxAngle: 90,

                transitionMs: 750,

                majorTicks: 5,
                labelFormat: d3.format(',g'),
                labelInset: 10,

                arcColorFn: d3.interpolateHsl(d3.rgb('#e8e2ca'), d3.rgb('#3e6c0a'))
            };
            var range = undefined;
            var r = undefined;
            var pointerHeadLength = undefined;
            var value = 0;

            var svg = undefined;
            var arc = undefined;
            var scale = undefined;
            var ticks = undefined;
            var tickData = undefined;
            var pointer = undefined;

            var donut = d3.layout.pie();

            function deg2rad(deg) {
                return deg * Math.PI / 180;
            }

            function newAngle(d) {
                var ratio = scale(d);
                var newAngle = config.minAngle + (ratio * range);
                return newAngle;
            }

            function configure(configuration) {
                var prop = undefined;
                for (prop in configuration) {
                    config[prop] = configuration[prop];
                }

                range = config.maxAngle - config.minAngle;
                r = config.size / 2;
                pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);

                // a linear scale that maps domain values to a percent from 0..1
                scale = d3.scale.linear()
                    .range([0, 1])
                    .domain([config.minValue, config.maxValue]);

                ticks = scale.ticks(config.majorTicks);
                tickData = d3.range(config.majorTicks).map(function () {
                    return 1 / config.majorTicks;
                });

                arc = d3.svg.arc()
                    .innerRadius(r - config.ringWidth - config.ringInset)
                    .outerRadius(r - config.ringInset)
                    .startAngle(function (d, i) {
                        var ratio = d * i;
                        return deg2rad(config.minAngle + (ratio * range));
                    })
                    .endAngle(function (d, i) {
                        var ratio = d * (i + 1);
                        return deg2rad(config.minAngle + (ratio * range));
                    });
            }
            that.configure = configure;

            function centerTranslation() {
                return 'translate(' + r + ',' + r + ')';
            }

            function isRendered() {
                return (svg !== undefined);
            }
            that.isRendered = isRendered;

            function render(newValue) {
                svg = d3.select(container)
                    .append('svg:svg')
                    .attr('class', 'gauge')
                    .attr('width', config.clipWidth)
                    .attr('height', config.clipHeight);

                var centerTx = centerTranslation();

                var arcs = svg.append('g')
                    .attr('class', 'arc')
                    .attr('transform', centerTx);

                arcs.selectAll('path')
                    .data(tickData)
                    .enter().append('path')
                    .attr('fill', function (d, i) {
                        return config.arcColorFn(d * i);
                    })
                    .attr('d', arc);

                var lg = svg.append('g')
                    .attr('class', 'label')
                    .attr('transform', centerTx);
                lg.selectAll('text')
                    .data(ticks)
                    .enter().append('text')
                    .attr('transform', function (d) {
                        var ratio = scale(d);
                        var newAngle = config.minAngle + (ratio * range);
                        return 'rotate(' + newAngle + ') translate(0,' + (config.labelInset - r) + ')';
                    })
                    .text(config.labelFormat);

                var lineData = [
                    [config.pointerWidth / 2, 0],
                    [0, -pointerHeadLength],
                    [-(config.pointerWidth / 2), 0],
                    [0, config.pointerTailLength],
                    [config.pointerWidth / 2, 0]
                ];
                var pointerLine = d3.svg.line().interpolate('monotone');
                var pg = svg.append('g').data([lineData])
                    .attr('class', 'pointer')
                    .attr('transform', centerTx);

                pointer = pg.append('path')
                    .attr('d', pointerLine /*function(d) { return pointerLine(d) +'Z';}*/ )
                    .attr('transform', 'rotate(' + config.minAngle + ')');

                update(newValue === undefined ? 0 : newValue);
            }
            that.render = render;

            function update(newValue, newConfiguration) {
                if (newConfiguration !== undefined) {
                    configure(newConfiguration);
                }
                var ratio = scale(newValue);
                var newAngle = config.minAngle + (ratio * range);
                pointer.transition()
                    .duration(config.transitionMs)
                    .ease('elastic')
                    .attr('transform', 'rotate(' + newAngle + ')');
            }
            that.update = update;

            configure(configuration);

            return that;
        };
    </script>

    <script>
        function onDocumentReady() {
            parsedCpuUtil = [];
            parsedRamUtil = [];
            var powerGaugeRamUtil = gauge('#power-gauge-ramutil', {
                size: 300,
                clipWidth: 300,
                clipHeight: 300,
                ringWidth: 60,
                maxValue: 100,
                transitionMs: 4000,
            });
            var powerGaugeCpuUtil = gauge('#power-gauge-cpuutil', {
                size: 300,
                clipWidth: 300,
                clipHeight: 300,
                ringWidth: 60,
                maxValue: 100,
                transitionMs: 4000,
            });
            powerGaugeRamUtil.render();
            powerGaugeCpuUtil.render();

            function updateRamUtil(data) {
                // just pump in random data here...
                powerGaugeRamUtil.update(data);
            }

            function updateCpuUtil(data) {
                // just pump in random data here...
                powerGaugeCpuUtil.update(data);
            }

            // var margin = { top: 30, right: 20, bottom: 30, left: 50 },
            //     width = 600 - margin.left - margin.right,
            //     height = 270 - margin.top - margin.bottom;

            // var x = d3.time.scale().range([0, width]);
            // var y = d3.scale.linear().range([height, 0]);

            // var xAxis = d3.svg.axis().scale(x)
            //     .orient("bottom").ticks(5);

            // var yAxis = d3.svg.axis().scale(y)
            //     .orient("left").ticks(5);

            // // Define the line
            // var valueline = d3.svg.line()
            //     .x(function (d) { return x(d.date); })
            //     .y(function (d) { return y(d.value); });


            // var svg = d3.select("body").append("svg")
            //     .attr("width", width + margin.left + margin.right)
            //     .attr("height", height + margin.top + margin.bottom)
            //     .append("g")
            //     .attr("transform",
            //         "translate(" + margin.left + "," + margin.top + ")");


            // x.domain(d3.extent(parsedCpuUtil, function (d) { return d.date; }));
            // y.domain([0, d3.max(parsedCpuUtil, function (d) { return d.value; })]);

            // // Add the valueline path.
            // svg.append("path")
            //     .data([parsedCpuUtil])
            //     .attr("class", "line")
            //     .attr("d", valueline);

            // // Add the X Axis
            // svg.append("g")
            //     .attr("transform", "translate(0," + height + ")")
            //     .call(d3.axisBottom(x));

            // // Add the Y Axis
            // svg.append("g")
            //     .call(d3.axisLeft(y));


            var socket = io.connect('http://localhost:8001');
            socket.on('ramUtil', function (data) {
                updateRamUtil(data)
            })
            socket.on('cpuUtil', function (data) {
                updateCpuUtil(data);
            })
        }

        if (!window.isLoaded) {
            window.addEventListener("load", function () {
                onDocumentReady();
            }, false);
        } else {
            onDocumentReady();
        }
    </script>

    <script>
        var timeoutId = 0;
        var data = [],
            ramData = [];

        var margin = {
                top: 20,
                right: 20,
                bottom: 30,
                left: 50
            },
            width = 800 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;

        var parseDate = d3.time.format("%H:%M:%S").parse;

        var xcenter = width / 2;

        var x = d3.time.scale()
            .range([0, width]);

        var y = d3.scale.linear()
            .range([height, 0]);

        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom")
            .tickFormat(d3.time.format("%S"));

        var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left");

        var line = d3.svg.line()
            .x(function (d) {
                return x(d.creatTime);
            })
            .y(function (d) {
                return y(d.cpuTime);
            });

        // var ramLine = d3.svg.line()
        //     .x(function (d) {
        //         return x(d.creatTime);
        //     })
        //     .y(function (d) {
        //         return y(d.cpuTime);
        //     });

        // function

        function myGetTime() {
            var dd = new Date();
            var hh = dd.getHours();
            var mm = dd.getMinutes();
            var ss = dd.getSeconds();
            return hh + ":" + mm + ":" + ss;
        }

        function getTime(data, d) {
            if (data.length === 25) {
                // when length of data equal 60 then pop data[0]
                data.shift();
            }
            data.push({
                "creatTime": myGetTime(),
                "cpuTime": d,
            });
        }

        var socket = io.connect('http://localhost:8001');

        socket.on('cpuUtil', function (d) {
            getTime(data, d);
            render();;
        })
        
        socket.on('ramUtil', function (d) {
            getTime(ramData, d);
            console.log(d)
            render();
        })

        function render() {

            d3.select("#cpu")
                .remove();

            var svg = d3.select("#cpu-line-chart").append("svg")
                .attr("id", "cpu")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom + 40)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            data.forEach(function (d) {
                if (typeof d.creatTime === "string") {
                    d.cpuTime = +d.cpuTime;
                    d.creatTime = parseDate(d.creatTime);
                }

            });

            data.forEach(function (d) {
                if (typeof d.creatTime === "string") {
                    d.cpuTime = +d.cpuTime;
                    d.creatTime = parseDate(d.creatTime);
                }

            });

            // x.domain(d3.extent(ramData, function (d) {
            //     return d.creatTime;
            // }));
            // y.domain(d3.extent(ramData, function (d) {
            //     return d.cpuTime;
            // }));

            x.domain(d3.extent(data, function (d) {
                return d.creatTime;
            }));
            y.domain(d3.extent(data, function (d) {
                return d.cpuTime;
            }));

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .style("text-anchor", "end")
                .call(xAxis)
                .append("text")
                .attr("transform", "rotate(0)")
                .attr("y", 40)
                .attr("dx", xcenter)
                .attr("font-size", "1.3em")
                .style("text-anchor", "end")
                .text("time(s)");

            svg.append("g")
                .attr("class", "y axis")
                // .attr("transform", "translate(" + height + ",-180px)")
                .style("text-anchor", "end")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -40)
                .attr("dy", ".41em")
                .attr("font-size", "1.3em")
                .style("text-anchor", "end")
                .text("CPU%");

            svg.append("path")
                .datum(data)
                .attr("class", "line")
                .attr("d", line);

            // svg.append("path")
            //     .datum(data)
            //     .attr("class", "line")
            //     .attr("d", cpuLine);
        }

        // Start
        // update();
    </script>
</body>

</html>